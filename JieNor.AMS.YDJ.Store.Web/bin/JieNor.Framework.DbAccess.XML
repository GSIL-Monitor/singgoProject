<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JieNor.Framework.DbAccess</name>
    </assembly>
    <members>
        <member name="M:PerfmonUtil.StartMonitor">
            <summary>
            开始监控
            </summary>
        </member>
        <member name="M:PerfmonUtil.EndMonitor">
            <summary>
            结束监控
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.GetParameter(System.Data.Common.DbConnection,System.String,System.Data.DbType,System.Int32,System.Data.ParameterDirection,System.Boolean,System.Byte,System.Byte,System.String,System.Data.DataRowVersion,System.Object)">
            <summary>
            Configures a given <see cref="T:System.Data.Common.DbParameter"/>.
            </summary>
            <param name="param">The <see cref="T:System.Data.Common.DbParameter"/> to configure.</param>
            <param name="name"><para>The name of the parameter.</para></param>
            <param name="dbType"><para>One of the <see cref="P:JieNor.Framework.DbAccess.Database.AbstractDatabase.DbType"/> values.</para></param>
            <param name="size"><para>The maximum size of the data within the column.</para></param>
            <param name="direction"><para>One of the <see cref="T:System.Data.ParameterDirection"/> values.</para></param>
            <param name="nullable"><para>Avalue indicating whether the parameter accepts <see langword="null"/> (<b>Nothing</b> in Visual Basic) values.</para></param>
            <param name="precision"><para>The maximum number of digits used to represent the <paramref name="value"/>.</para></param>
            <param name="scale"><para>The number of decimal places to which <paramref name="value"/> is resolved.</para></param>
            <param name="sourceColumn"><para>The name of the source column mapped to the DataSet and used for loading or returning the <paramref name="value"/>.</para></param>
            <param name="sourceVersion"><para>One of the <see cref="T:System.Data.DataRowVersion"/> values.</para></param>
            <param name="value"><para>The value of the parameter.</para></param>  
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.ExecuteDataSet(System.Data.Common.DbCommand,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam})">
            <summary>
            返回dataSet数据集
            </summary>
            <param name="command"></param>
            <param name="listParam"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.ExecuteDataSet(System.Data.Common.DbCommand,System.Data.DataSet,System.String,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam})">
            <summary>
            返回dataSet数据集
            </summary>
            <param name="command"></param>
            <param name="dataSet"></param>
            <param name="tableName"></param>
            <param name="listParam"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.GetOpenConnection">
            <summary>
            	Get's a "wrapped" connection that will be not be disposed if a transaction is
            	active (created by creating a <see cref="T:System.Transactions.TransactionScope"/> instance). The
            	connection will be disposed when no transaction is active.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.LoadDataSet(System.Data.Common.DbCommand,System.Data.DataSet,System.String,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam})">
            <summary>
            <para>Executes the <paramref name="command"/> and adds a new <see cref="T:System.Data.DataTable"></see> to the existing <see cref="T:System.Data.DataSet"></see>.</para>
            </summary>
            <param name="command">
            <para>The <see cref="T:System.Data.Common.DbCommand"/> to execute.</para>
            </param>
            <param name="dataSet">
            <para>The <see cref="T:System.Data.DataSet"/> to load.</para>
            </param>
            <param name="tableName">
            <para>The name for the new <see cref="T:System.Data.DataTable"/> to add to the <see cref="T:System.Data.DataSet"/>.</para>
            </param>        
            <exception cref="T:System.ArgumentNullException">Any input parameter was <see langword="null"/> (<b>Nothing</b> in Visual Basic)</exception>
            <exception cref="T:System.ArgumentException">tableName was an empty string</exception>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.LoadDataSet(System.Data.Common.DbCommand,System.Data.DataSet,System.String,System.Data.Common.DbTransaction)">
            <summary>
            <para>Executes the <paramref name="command"/> within the given <paramref name="transaction" /> and adds a new <see cref="T:System.Data.DataTable"></see> to the existing <see cref="T:System.Data.DataSet"></see>.</para>
            </summary>
            <param name="command">
            <para>The <see cref="T:System.Data.Common.DbCommand"/> to execute.</para>
            </param>
            <param name="dataSet">
            <para>The <see cref="T:System.Data.DataSet"/> to load.</para>
            </param>
            <param name="tableName">
            <para>The name for the new <see cref="T:System.Data.DataTable"/> to add to the <see cref="T:System.Data.DataSet"/>.</para>
            </param>
            <param name="transaction">
            <para>The <see cref="T:System.Data.IDbTransaction"/> to execute the command within.</para>
            </param>        
            <exception cref="T:System.ArgumentNullException">Any input parameter was <see langword="null"/> (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">tableName was an empty string.</exception>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.LoadDataSet(System.Data.Common.DbCommand,System.Data.DataSet,System.String[],System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam})">
            <summary>
            <para>Loads a <see cref="T:System.Data.DataSet"/> from a <see cref="T:System.Data.Common.DbCommand"/>.</para>
            </summary>
            <param name="command">
            <para>The command to execute to fill the <see cref="T:System.Data.DataSet"/>.</para>
            </param>
            <param name="dataSet">
            <para>The <see cref="T:System.Data.DataSet"/> to fill.</para>
            </param>
            <param name="tableNames">
            <para>An array of table name mappings for the <see cref="T:System.Data.DataSet"/>.</para>
            </param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.LoadDataSet(System.Data.Common.DbCommand,System.Data.DataSet,System.String[],System.Data.Common.DbTransaction)">
            <summary>
            <para>Loads a <see cref="T:System.Data.DataSet"/> from a <see cref="T:System.Data.Common.DbCommand"/> in  a transaction.</para>
            </summary>
            <param name="command">
            <para>The command to execute to fill the <see cref="T:System.Data.DataSet"/>.</para>
            </param>
            <param name="dataSet">
            <para>The <see cref="T:System.Data.DataSet"/> to fill.</para>
            </param>
            <param name="tableNames">
            <para>An array of table name mappings for the <see cref="T:System.Data.DataSet"/>.</para>
            </param>
            <param name="transaction">
            <para>The <see cref="T:System.Data.IDbTransaction"/> to execute the command in.</para>
            </param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.GetDataAdapter">
            <summary>
            Gets the DbDataAdapter with the given update behavior and connection from the proper derived class.
            </summary>
            <param name="updateBehavior">
            <para>One of the <see cref="!:UpdateBehavior"/> values.</para>
            </param>        
            <returns>A <see cref="T:System.Data.Common.DbDataAdapter"/>.</returns>
            <seealso cref="T:System.Data.Common.DbDataAdapter"/>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.PrepareCommand(System.Data.Common.DbCommand,System.Data.Common.DbTransaction)">
            <summary>
            <para>Assigns a <paramref name="transaction"/> to the <paramref name="command"/> and discovers parameters if needed.</para>
            </summary>
            <param name="command"><para>The command that contains the query to prepare.</para></param>
            <param name="transaction">The transaction to assign to the command.</param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.LoadDataSet(System.Data.CommandType,System.String,System.Data.DataSet,System.String[])">
            <summary>
            <para>Loads a <see cref="T:System.Data.DataSet"/> from command text.</para>
            </summary>
            <param name="commandType">
            <para>One of the <see cref="T:System.Data.CommandType"/> values.</para>
            </param>
            <param name="commandText">
            <para>The command text to execute.</para>
            </param>
            <param name="dataSet">
            <para>The <see cref="T:System.Data.DataSet"/> to fill.</para>
            </param>
            <param name="tableNames">
            <para>An array of table name mappings for the <see cref="T:System.Data.DataSet"/>.</para>
            </param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.LoadDataSet(System.Data.Common.DbTransaction,System.Data.CommandType,System.String,System.Data.DataSet,System.String[])">
            <summary>
            <para>Loads a <see cref="T:System.Data.DataSet"/> from command text in a transaction.</para>
            </summary>
            <param name="transaction">
            <para>The <see cref="T:System.Data.IDbTransaction"/> to execute the command in.</para>
            </param>
            <param name="commandType">
            <para>One of the <see cref="T:System.Data.CommandType"/> values.</para>
            </param>
            <param name="commandText">
            <para>The command text to execute.</para>
            </param>
            <param name="dataSet">
            <para>The <see cref="T:System.Data.DataSet"/> to fill.</para>
            </param>
            <param name="tableNames">
            <para>An array of table name mappings for the <see cref="T:System.Data.DataSet"/>.</para>
            </param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.ExecuteScalar(System.Data.Common.DbCommand,JieNor.Framework.SqlParam[])">
            <summary>
            
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.AbstractDatabase.ConvertTableFun(System.Data.Common.DbCommand)">
            <summary>
            将表值函数进行转换
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="T:JieNor.Framework.DbAccess.Database.BatchUpdateObject">
            <summary>
            批量更新对象，包括：表数据Datatable、更新语句CommandText
            </summary>
        </member>
        <member name="T:JieNor.Framework.DbAccess.Database.ConnectionWrapper">
            <summary>
            	This is a helper class that is used to manage the lifetime of a connection for various
            	Execute methods. We needed this class to support implicit transactions created with
            	the <see cref="!:TransactionScope"/> class. In this case, the various Execute methods
            	need to use a shared connection instead of a new connection for each request in order
            	to prevent a distributed transaction.
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.ConnectionWrapper.#ctor(System.Data.Common.DbConnection,System.Boolean)">
            <summary>
            	Create a new "lifetime" container for a <see cref="T:System.Data.Common.DbConnection"/> instance.
            </summary>
            <param name="connection">The connection</param>
            <param name="disposeConnection">
            	Whether or not to dispose of the connection when this class is disposed.
            </param>
        </member>
        <member name="P:JieNor.Framework.DbAccess.Database.ConnectionWrapper.Connection">
            <summary>
            	Gets the actual connection.
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.ConnectionWrapper.Dispose">
            <summary>
            	Dispose the wrapped connection, if appropriate.
            </summary>
        </member>
        <member name="T:JieNor.Framework.DbAccess.Database.DataReaderEnumerable`1">
            <summary>
            将IDataReader对象的值进行读取，使之支持枚举功能
            </summary>
            <typeparam name="T">要读取的数据类型</typeparam>
            <remarks>
            注意在枚举完毕后本类会自动关闭读取器
            </remarks>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.DataReaderEnumerable`1.#ctor(System.Func{System.Data.IDataReader},System.Func{System.Data.IDataRecord,`0})">
            <summary>
            构建新的实例
            </summary>
            <param name="getReaderFunc">通过此函数获取一个读取器对象</param>
            <param name="getValueFunc">一个委托当读取到某行时，从此行中获取想要的值。</param>
        </member>
        <member name="P:JieNor.Framework.DbAccess.Database.DataReaderEnumerable`1.IgnoreNull">
            <summary>
            返回/设置是否忽略Null的值，默认为false
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.DataReaderEnumerable`1.GetEnumerator">
            <summary>
            获取枚举器，此枚举器将获取每行你想要的值
            </summary>
            <returns>枚举器对象</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.DataReaderEnumerable`1.OnStarting(System.Data.IDataReader)">
            <summary>
            即将开始枚举操作时的调用，允许派生类提前准备索引这样的事情。
            </summary>
            <param name="dataReader">读取器</param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.DataReaderEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            获取枚举器，此枚举器将获取每行你想要的值
            </summary>
            <returns>枚举器对象</returns>
        </member>
        <member name="T:JieNor.Framework.DbAccess.Database.DataReaderEnumerable">
            <summary>
            非泛型版本的枚举器，将第一个字段的值输出
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.DataReaderEnumerable.#ctor(System.Func{System.Data.IDataReader})">
            <summary>
            创建实例，并设置IgnoreDbNull = true
            </summary>
            <param name="getReaderFunc">通过此函数获取一个读取器对象</param>
            <param name="fieldName">要输出的字段，如果未设置将默认输出第一列</param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.IDatabase.ExecuteDataSet(System.Data.Common.DbCommand,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam})">
            <summary>
            返回dataSet数据集
            </summary>
            <param name="cmd"></param>
            <param name="listParam"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.IDatabase.ExecuteDataSet(System.Data.Common.DbCommand,System.Data.DataSet,System.String,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam})">
            <summary>
            返回dataSet数据集
            </summary>
            <param name="command"></param>
            <param name="dataSet"></param>
            <param name="tableName"></param>
            <param name="listParam"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.ProclaimText.DoProclaimText(System.String)">
            <summary>
            对字符串进行解密
            </summary>
            <param name="proclaimText"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.SqlObject.#ctor(System.String,System.Collections.Generic.List{JieNor.Framework.SqlParam})">
            <summary>
            sql对象
            </summary>
            <param name="sql">sql语句</param>
            <param name="paramList">参数列表</param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.SqlObject.#ctor(System.String,JieNor.Framework.SqlParam)">
            <summary>
            sql对象
            </summary>
            <param name="sql">sql语句</param>
            <param name="param">参数</param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.SqlServer.SqlDatabase.ExecuteBatch(System.Collections.Generic.List{System.String},System.Int32,System.Int32)">
            <summary>
            批量执行
            </summary>
            <param name="sqlArray"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="T:JieNor.Framework.DbAccess.Database.TransactionScopeConnections">
            <summary>
            	This class manages the connections that will be used when transactions are active
            	as a result of instantiating a <see cref="T:System.Transactions.TransactionScope"/>. When a transaction
            	is active, all database access must be through this single connection unless you want
            	to use a distributed transaction, which is an expensive operation.
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.TransactionScopeConnections.GetConnection(JieNor.Framework.DbAccess.Database.IDatabase)">
            <summary>
            	Returns a connection for the current transaction. This will be an existing <see cref="T:System.Data.Common.DbConnection"/>
            	instance or a new one if there is a <see cref="T:System.Transactions.TransactionScope"/> active. Otherwise this method
            	returns null.
            </summary>
            <param name="db"></param>
            <returns>Either a <see cref="T:System.Data.Common.DbConnection"/> instance or null.</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.Database.TransactionScopeConnections.OnTransactionCompleted(System.Object,System.Transactions.TransactionEventArgs)">
            <summary>
            	This event handler is called whenever a transaction is about to be disposed, which allows
            	us to remove the transaction from our list and dispose the connection instance we created.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:JieNor.Framework.DbAccess.DbTemporaryTableUtil">
            <summary>
            临时表服务,临时表名的产生和临时表的维护
            临时表名保存和返回的值为大写，不能调整，否则会由于ORACLE（表名默认为大写）的大小写敏感导致没有被删除的问题
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.CreateTemporaryTableName(JieNor.Framework.UserContext)">
            <summary>
            创建临时表名称，系统将统一进行维护,如果ctx和执行语句出现异常将返回空对象名称
            </summary>
            <param name="ctx">上下文，如果为null返回空串</param>
            <returns>返回生成的表名,大写</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.GetUserTransactionId(JieNor.Framework.UserContext)">
            <summary>
            获得用户UserTransactionId
            </summary>
            <param name="ctx"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.CreateTemporaryTableName(JieNor.Framework.UserContext,System.String[],System.Boolean)">
            <summary>
            根据指定前缀请求临时表名,表名的后缀的27位GUID值是相同的
            注意前缀必须是3位字符
            </summary>
            <param name="ctx"></param>
            <param name="prefixItems"></param>
            <param name="prefixAsTableName"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.CreateTemporaryTableName(JieNor.Framework.UserContext,System.Int32)">
            <summary>
            生成指定数目的临时表,并以数组的方式返回，如果ctx对象为空或者执行出错将返回空对象
            </summary>
            <param name="ctx">上下文</param>
            <param name="count">需要获取临时表的个数</param>
            <returns>返回生成的临时表数组</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.DeleteTemporaryTableName(JieNor.Framework.UserContext,System.String[])">
            <summary>
            删除指定的临时表，如果ctx为null，tablenames为空集合，返回为true，执行SQL出错时将返回false
            但实际上并不进行临时表的删除操作，只是将可以删除的临时表打上标记
            </summary>
            <param name="ctx">上下文</param>
            <param name="tablenames">需要删除的临时表集合</param>
            <returns>执行成功和ctx为null，tablenames为空集合，返回为true</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.DeleteTemporaryTableName(JieNor.Framework.UserContext)">
            <summary>
            删除Contxtx中对应usertoken的临时表
            但实际上并不进行临时表的删除操作，只是将可以删除的临时表打上标记
            </summary>
            <param name="ctx">上下文</param>
            <returns>执行出错返回false</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.GetNeedDeleteTableSql(JieNor.Framework.UserContext)">
            <summary>
            获取可以清理表的SQL语句
            </summary>
            <param name="ctx"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.ClearConflictInfo(JieNor.Framework.UserContext)">
            <summary>
            清除数据库中已经不存在，但在T_BAS_TEMPORARYTABLENAME存在的表,并且忽略异常 
            </summary>
            <param name="ctx"></param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DbTemporaryTableUtil.DropAllTemporaryTable(JieNor.Framework.UserContext)">
            <summary>
            删除当前日期之前24小时建立的所有临时表和已经标记为可以删除的临时表，即当临时表在一天前创建的，并且对应的状态为不可删除时，也是会被进行清理的
            此操作将实际删除物理表，并且清除临时表中相应的记录
            该方法只供服务调用，业务代码中不应该进行调用
            </summary>
            <param name="ctx">上下文</param>
            <returns>成功返回true</returns>
        </member>
        <member name="T:JieNor.Framework.DbAccess.DBUtils">
            <summary>
            数据库访问层
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteReader(JieNor.Framework.UserContext,System.String)">
            <summary>
            流方式读SQL查询结果。
            </summary>
            <param name="ctx">上下文</param>
            <param name="strSQL">SQL语句</param>
            <returns>返回DataReader</returns>
            
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteReader(JieNor.Framework.UserContext,System.String,System.Data.CommandType)">
            <summary>
            返回DataReader，指定命令类型
            </summary>
            <param name="ctx">上下文</param>
            <param name="strSQL">SQL语句，如果为存储过程那么对应为存储过程名称</param>
            <param name="cmdtype">命令类型：Text||StoredProcedure</param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteReader(JieNor.Framework.UserContext,System.String,JieNor.Framework.SqlParam)">
            <summary>
            返回DataReader，一个参数
            </summary>
            <param name="ctx">上下文</param>
            <param name="strSQL">参数化SQL语句</param>
            <param name="param">参数</param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteReader(JieNor.Framework.UserContext,System.String,JieNor.Framework.SqlParam,System.Data.CommandType)">
            <summary>
            返回DataReader，一个参数
            </summary>
            <param name="ctx">上下文</param>
            <param name="strSQL">参数化SQL语句</param>
            <param name="param">参数</param>
            <param name="cmdtype">命令类型：Text||StoredProcedure</param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteReader(JieNor.Framework.UserContext,System.String,System.Collections.Generic.List{JieNor.Framework.SqlParam})">
            <summary>
            返回DataReader，多个参数
            </summary>
            <param name="ctx">上下文</param>
            <param name="strSQL">参数化SQL语句</param>
            <param name="paramList">参数对象列表</param> <seealso cref="T:JieNor.Framework.SqlParam"/>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteReader(JieNor.Framework.UserContext,System.String,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam},System.Data.CommandType)">
            <summary>
            返回DataReader，多个参数
            </summary>
            <param name="ctx">上下文</param>
            <param name="strSQL">参数化SQL语句</param>
            <param name="paramList">参数对象列表</param><seealso cref="T:JieNor.Framework.SqlParam"/>
            <param name="cmdtype">命令类型：Text||StoredProcedure</param>
            <returns></returns>
            <example>示例显示如何使用ExecuteReader获取数据
            <code>
            <![CDATA[
            string sql = string.Format("SELECT FKEY, FUSERID, FPARAMETERS FROM {0} WHERE FID = @FId", BOSTableConst.UserParamter);
            List<SqlParam> paramList = new List<SqlParam>();
            paramList.Add(new SqlParam("@FId", DbType.String, sid));
            using (IDataReader dr = DBUtils.ExecuteReader(ctx, sql, paramList))
            {
                if (dr.Read())
                {
                    key = dr.GetString("FKEY");
                    userId = dr.GetString("FUSERID");
                    parameter = dr.GetString("FPARAMETERS");
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteDataSet(JieNor.Framework.UserContext,System.String,System.Data.DataSet,System.String,System.Collections.Generic.List{JieNor.Framework.SqlParam})">
            <summary>
            返回dataSet数据集
            </summary>
            <param name="ctx"></param>
            <param name="strSQL"></param>
            <param name="ds"></param>
            <param name="tableName"></param>
            <param name="paramList"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteEnumerable(JieNor.Framework.UserContext,System.String,System.Data.CommandType,JieNor.Framework.SqlParam[])">
            <summary>
            执行SQL语句并返回一个枚举器对象
            </summary>
            <param name="ctx">上下文对象</param>
            <param name="strSQL">要执行的SQL语句</param>
            <param name="cmdType">语句类型</param>
            <param name="paramList">参数列表</param>
            <returns>返回一个枚举器，此枚举器在枚举完毕或失败后会自动关闭连接</returns>
            <remarks>
            <example>
            下面的代码演示了执行SQL并获取数据的例子
            <code>
            <![CDATA[
             var data = from p in DBUtils.ExecuteEnumerable(this.ctx, "Select FId,FElementTypeId FROM t_Form")
                        select new
                        {
                            Id = p.GetValue<string>(0),
                            ElementTypeId = p.GetValue<int>(1,Convert.ToInt32)
                        };
             foreach (var item in data)
             {
                 Console.WriteLine(item.Id + item.ElementTypeId.ToString());
             }
            ]]>
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteObject``1(JieNor.Framework.UserContext,System.String,JieNor.Framework.SuperOrm.Metadata.DataEntity.IDataEntityType,System.Collections.Generic.IDictionary{System.String,System.Type},System.Data.CommandType,JieNor.Framework.SqlParam[])">
            <summary>
            执行指定的SQL并返回默认的一批使用实体集合描述的数据。
            </summary>
            <param name="ctx">上下文对象</param>
            <param name="strSQL">要执行的SQL语句</param>
            <param name="dt">如果指定此参数，那么执行后的SQL将自动按此类型填充数据。否则将根据返回的记录集自动创建类型。</param>
            <param name="propertyTypeMaps">如果指定此参数，可以设定某个字段应该的数据类型。</param>
            <param name="cmdType">指定SQL的类型</param>
            <param name="paramList">参数类型</param>
            <returns>一组动态实体对象。</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.BuildDtFromDbReader(System.Data.IDataReader,System.Collections.Generic.IDictionary{System.String,System.Type},JieNor.Framework.SuperOrm.Metadata.DataEntity.ISimpleProperty[]@)">
            <summary>
            根据DataReader的字段类型信息，推导出一个动态实体类型，可以指定特定的列使用指定的数据类型
            </summary>
            <param name="reader">数据读取器</param>
            <param name="propertyTypeMaps">可选参数，可以指定特定名称的列使用指定的数据类型。</param>
            <param name="propertitesMap">返回某个索引对应的属性描述符。</param>
            <returns>一个新的动态实体类型。</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteDynamicObject(JieNor.Framework.UserContext,System.String,JieNor.Framework.SuperOrm.Metadata.DataEntity.IDataEntityType,System.Collections.Generic.IDictionary{System.String,System.Type},System.Data.CommandType,JieNor.Framework.SqlParam[])">
            <summary>
            执行指定的SQL并返回默认的一批使用DynamicObject集合描述的数据。
            </summary>
            <param name="ctx">上下文对象</param>
            <param name="strSQL">要执行的SQL语句</param>
            <param name="dt">如果指定此参数，那么执行后的SQL将自动按此类型填充数据。否则将根据返回的记录集自动创建类型。</param>
            <param name="propertyTypeMaps">如果指定此参数，可以设定某个字段应该的数据类型。</param>
            <param name="cmdType">指定SQL的类型</param>
            <param name="paramList">参数类型</param>
            <returns>一组动态实体对象。</returns>
            <example>
            <code>
            string sql = "SELECT FDESCRIPTION,FLOCALEID FROM T_BF_PROCDEF_L WHERE FID = @FID";
            DynamicObjectCollection objs = DBUtils.ExecuteDynamicObject(this.UserContext, sql, paramList: new SqlParam[] { new SqlParam("@FID", DbType.String, metadata.Id) });
            foreach (DynamicObject obj in objs)
            {
                if (metadata.Description == null)
                {
                    metadata.Description = new LocaleValue();
                }
                int localeId = Convert.ToInt32(obj["FLOCALEID"]);
                metadata.Description[localeId] = (string)obj["FDESCRIPTION"];
            }
            </code>
            </example>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ClearConnectionStrings">
            <summary>
            清楚数据库连接串的缓存
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.Execute(JieNor.Framework.UserContext,System.String)">
            <summary>
            执行SQL语句
            </summary>
            <param name="ctx">上下文对象</param>
            <param name="strSQL">要执行的SQL语句</param>
            <returns>影响的行数</returns>
            <remarks>
            Execute方法用于不需要返回数据的执行语句，如DDL、UPDATE、DELETE语句。返回值为影响的行数。
            Execute方法每次仅执行一条语句，对SQLServer支持多条语句一起执行，因此多条语句拼在一起执行没有问题，但Oracle下执行会报错。
            如果需要执行多条语句，请调用批量执行方法：ExecuteBatch。
            如果要执行SELECT语句，建议使用ExecuteReader方法。
            </remarks>
            <example>
            <code>
            Execute(ctx, " CREATE TABLE T_TEMP(FID INT NOT NULL, FNAME VARCHAR(10) NULL ) ");
            </code>
            </example>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.Execute(JieNor.Framework.UserContext,System.String,JieNor.Framework.SqlParam)">
            <summary>
            执行带查询参数的SQL语句
            </summary>
            <param name="ctx">上下文对象</param>
            <param name="strSQL">要执行的SQL语句</param>
            <param name="param">SQL语句的参数</param>
            <returns>影响的行数</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.Execute(JieNor.Framework.UserContext,System.String,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam})">
            <summary>
            
            </summary>
            <param name="ctx"></param>
            <param name="strSQL"></param>
            <param name="paramList"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteWithTime(JieNor.Framework.UserContext,System.String,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam},System.Int32)">
            <summary>
            执行指定sql语句，并引入超时机制（非特殊的大事务功能不要定制这个参数）
            </summary>
            <param name="ctx"></param>
            <param name="strSQL"></param>
            <param name="paramList"></param>
            <param name="commandTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteScalar(JieNor.Framework.UserContext,System.String,System.Collections.Generic.List{JieNor.Framework.SqlParam})">
            <summary>
            返回数据的第一行第一列
            </summary>
            <param name="ctx">上下文</param>
            <param name="strSQL">需要执行的SQL语句</param>
            <param name="paramList">产生列表</param>
            <returns>返回数据的第一行第一列</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteScalar``1(JieNor.Framework.UserContext,System.String,``0,JieNor.Framework.SqlParam[])">
            <summary>
            执行某个SQL并获取第一行第一列的值，如果数据未找到或为DBNULL，那么将返回缺省值
            </summary>
            <typeparam name="T">返回的数据类型</typeparam>
            <param name="ctx">上下文</param>
            <param name="strSql">要执行的SQL语句</param>
            <param name="defaultValue">如果数据未找到或为DBNULL，那么将返回此值。如果T是int?，那么可以指定此参数为null，从而实现没有记录时为null而不是0的功能。</param>
            <param name="paramList">参数</param>
            <returns>结果</returns>
            <example>示例根据条件获取记录数，若没有数据，记录数为0
            <code>
            <![CDATA[
            string sql = " SELECT COUNT(1) FROM T_DEMO ";
            int count = DBUtils.ExecuteScalar<int>(this.UserContext, sql, 0, null);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.BulkInserts(JieNor.Framework.UserContext,System.String,System.Data.DataTable)">
            <summary>
            批量插入数据
            </summary>
            <remarks>
            可以指定建表语句将数据批量插入到新表中。在使用临时表实现业务功能时指定该参数非常方便。
            INSERT语句的字段必须与DataTable匹配。否则执行将报错。
            </remarks>
            <param name="ctx">上下文对象</param>
            <param name="CreateSql">建表语句，为""表示没有建表语句</param>
            <param name="dt">插入表的数据</param>
            <example>
            下面代码展示使用临时表实现大数据量关联查询
            <code>
            DataTable dt = new DataTable();
            dt.Columns.Add("FID");
            dt.BeginLoadData();
            foreach (var id in fIds)
            {
                dt.LoadDataRow(new object[] { id }, true);
            }
            dt.EndLoadData();
            dt.TableName = "T_TEMP";
            using (KDTransactionScope scope = new KDTransactionScope(System.Transactions.TransactionScopeOption.Suppress))
            {
                //创建临时表并插入数据
                DBUtils.BulkInserts(ctx, "INSERT INTO T_TEMP values(@FID)", "create table T_TEMP (FID INT)", dt);
                scope.Complete();
            }
            //关联取数
            IDataReader reader = DBUtils.ExecuteReader(ctx, " SELECT * FROM T_DEMO INNER JOIN T_TEMP ON T_DEMO.FID = T_TEMP.FID ");
            //删除临时表
            DeleteTemporaryTable(ctx, "T_TEMP");
            </code>
            </example>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteBatch(JieNor.Framework.UserContext,System.Collections.Generic.List{JieNor.Framework.DbAccess.Database.SqlObject})">
            <summary>
            批量执行SQL语句
            </summary>
            <param name="ctx">上下文</param>
            <param name="lstSqlObj">需要执行SQL语句的对象集合</param>
            <returns>最后一条语句影响的行数</returns>
            <example>
            示例展示使用ExecuteBatch批量执行sql语句方法。
            <code>
            <![CDATA[
            List<SqlObject> listSql = new List<SqlObject>();
            foreach (FieldValue val in fieldValues)
            {
                string sql = string.Format("UPDATE T_DEMO set {0} = {1} where FID = @FID ", val.FieldName, val.Value);
                
                SqlObject sqlObj = new SqlObject(sql, new Param("@FID", System.Data.DbType.Int32, id));
                listSql.Add(sql);
            }
            DBUtils.ExecuteBatch(UserContext, listSql);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteBatch(JieNor.Framework.UserContext,System.Collections.Generic.List{System.String},System.Int32)">
            <summary>
            不带参数的批量执行
            </summary>
            <remarks>
            批量运行SQL，适用于没有参数的多个SQL语句。要注意该方法的使用场景，应尽量使用参数化方法以减少执行计划分析时间。
            </remarks>
            <param name="ctx"></param>
            <param name="sqlArray">语句集合</param>
            <param name="batchSize">批大小</param>
            <returns>最后一条语句影响的行数</returns>
            <example>
            <code>
            foreach (string tablName in tableNames)
            {
                batchSql.Add(string.Format(" delete from {0} t where exists (select 1 from T_Task where FID = t.FTaskId) ", tablName));
            }
            DBUtils.ExecuteBatch(this.UserContext, batchSql, 50);
            </code>
            </example>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteBatchWithTime(JieNor.Framework.UserContext,System.Collections.Generic.List{JieNor.Framework.DbAccess.Database.SqlObject},System.Int32)">
            <summary>
            提供带有超时机制设置的批量执行接口
            </summary>
            <param name="ctx"></param>
            <param name="lstSqlObj"></param>
            <param name="commandTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.ExecuteBatchWithTime(JieNor.Framework.UserContext,System.Collections.Generic.List{System.String},System.Int32,System.Int32)">
            <summary>
            提供带有超时机制设置的批量执行接口
            </summary>
            <param name="ctx"></param>
            <param name="sqlArray"></param>
            <param name="batchSize"></param>
            <param name="commandTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.IsExistTable(JieNor.Framework.UserContext,System.String)">
            <summary>
            检测帐套是否存在某个物理表
            </summary>
            <param name="ctx">上下文对象</param>
            <param name="tableName">要检测的表名称</param>
            <returns>true表示存在此物理表</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.IsExistTableField(JieNor.Framework.UserContext,System.String,System.String)">
            <summary>
            检测帐套是否存在某个物理表的某个字段列
            </summary>
            <param name="ctx"></param>
            <param name="tableName"></param>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.IsExistView(JieNor.Framework.UserContext,System.String)">
            <summary>
            判断视图是否存在
            </summary>
            <param name="ctx"></param>
            <param name="ViewName"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.UpdateXml(JieNor.Framework.UserContext,System.String,System.Collections.Generic.IEnumerable{JieNor.Framework.SqlParam})">
            <summary>
            更新xml
            </summary>
            <param name="ctx"></param>
            <param name="strSQL">SQL语句</param>
            <param name="paramList">参数：value为xml（string）</param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBUtils.GetColumnType(System.Int32,JieNor.Framework.DatabaseType)">
            <summary>
            取得列类型字符串
            </summary>
            <param name="providerType">providerType，可以由IDataReader.GetSchemaTable()返回的Table中的DataRow来取，即dr["ProviderType"]</param>
            <param name="DatabaseType">数据库类型</param>
            <returns></returns>
        </member>
        <member name="T:JieNor.Framework.DbAccess.DBService">
            <summary>
            数据读取
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBService.CreateTempTableWithDataList(JieNor.Framework.UserContext,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            使用一组数据创建临时表，成功返回表名，表的列名默认为fid。
            </summary>
            <param name="ctx"></param>
            <param name="fIds"></param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.DBService.CreateTempTableWithSelectedRows(JieNor.Framework.UserContext,System.Collections.Generic.IEnumerable{JieNor.Framework.DataTransferObject.Poco.SelectedRow})">
            <summary>
            使用一组数据创建临时表，成功返回表名，表的列名默认为FID,FENTRYID,FENTITYKEY
            </summary>
            <param name="ctx"></param>
            <param name="lstSelectedRows"></param>
            <returns></returns>
        </member>
        <member name="T:JieNor.Framework.DbAccess.SequenceUtil">
            <summary>
            表主键的相关服务（获取、更新、修正等等）
            </summary>
        </member>
        <member name="M:JieNor.Framework.DbAccess.SequenceUtil.AutoSetPrimaryKey(JieNor.Framework.UserContext,System.Object,JieNor.Framework.SuperOrm.Metadata.DataEntity.IDataEntityType)">
            <summary>
            
            </summary>
            <param name="ctx"></param>
            <param name="obj"></param>
            <param name="entityType"></param>
        </member>
        <member name="M:JieNor.Framework.DbAccess.SequenceUtil.AutoSetPrimaryKey(JieNor.Framework.UserContext,System.Collections.Generic.IEnumerable{System.Object},JieNor.Framework.SuperOrm.Metadata.DataEntity.IDataEntityType)">
            <summary>
            为实体自动填充主键编号
            </summary>
            <param name="ctx"></param>
            <param name="obj">要填充的实体列表</param>
            <param name="entityType">实体的类型信息</param>
            <remarks>
            请尽量不要在应用服务器调用此方法，因为这可能造成编号的不连续，但这样不会造成错误。
            例如应用服务器先填充了编号（调用此方法），然后进行单据的校验，但是校验可能失败并抛出异常
            ，如果部署环境是物理分割的三层结构，这时Web服务器上的编号并没有变化，当再次保存时将重新填充新的编号。
            </remarks>
        </member>
        <member name="M:JieNor.Framework.DbAccess.SequenceUtil.GetSequence``1">
            <summary>
            返回指定个数的序列（仅支持 int64，string，guid三种类型）
            </summary>
            <typeparam name="T"></typeparam>  
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.SequenceUtil.GetSequence``1(System.Int32)">
            <summary>
            返回指定个数的序列（仅支持 int64，string，guid三种类型）
            </summary>
            <typeparam name="T"></typeparam> 
            <param name="count">需要申请的系列号个数</param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.SequenceUtil.GetInt64Sequence(System.Int32)">
            <summary>
            返回整数的序列
            </summary> 
            <param name="count">需要申请的系列号个数</param>
            <returns>指定数量的序列</returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.SequenceUtil.GetStringSequence(System.Int32)">
            <summary>
            
            </summary> 
            <param name="count">需要申请的系列号个数</param>
            <returns></returns>
        </member>
        <member name="M:JieNor.Framework.DbAccess.SequenceUtil.GetGuidSequence(System.Int32)">
            <summary>
            
            </summary> 
            <param name="count">需要申请的系列号个数</param>
            <returns></returns>
        </member>
    </members>
</doc>
